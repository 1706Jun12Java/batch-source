--2.1 SELECT
SELECT * FROM EMPLOYEE;

SELECT * FROM EMPLOYEE
WHERE LASTNAME = 'King';

SELECT * FROM EMPLOYEE
WHERE FIRSTNAME = 'Andrew'
AND
REPORTSTO is NULL;

--2.2 ORDER BY
SELECT * FROM ALBUM ORDER BY TITLE DESC;

SELECT FIRSTNAME FROM CUSTOMER ORDER BY CITY ASC;

--2.3 INSERT INTO
INSERT INTO GENRE (GENREID, NAME) values (26, 'NOTREAL');
INSERT INTO GENRE (GENREID, NAME) values (27, 'SOREAL');

INSERT INTO EMPLOYEE VALUES (9,'Memes','Dank', 'Meme Director', 1,'18-APR-95','02-JAN-17','123 S Columbus ave','Bronx', 'NY','USA','10466','+1 (516) 467-1394', '+1 (516) 467-1374','memelord@dank.com');
INSERT INTO EMPLOYEE VALUES (10, 'MEMER', 'SUPERDANK', 'DANK DIRECTOR', 1, '19-APR-20', '20-JAN-12', '123 APPLES STREET', 'BRONX', 'NY', 'USA', '11111', '+1 (123) 456-789', '+1 (123) 777-7777', 'DANK@LORD.COM');

INSERT INTO CUSTOMER VALUES (60, 'JOHN', 'Manner', NULL, '123 apple street', 'Apple City', 'NY', 'USA', '11333', '+1 (111) 222-3333', NULL, 'manner@gmail.com', 5);
INSERT INTO CUSTOMER VALUES (61, 'MIKE', 'DOOM', NULL, '123 orange street', 'Orange City', 'NJ', 'USA', '22444', '+1 (222) 333-4444', NULL, 'realorange@gmail.com', 3);

--2.4 UPDATE 
UPDATE CUSTOMER SET FIRSTNAME = 'Robert', LASTNAME = 'Walter'
WHERE FIRSTNAME = 'Aaron' AND LASTNAME = 'Mitchell';

UPDATE ARTIST SET NAME = 'CCR' WHERE NAME = 'Creedence Clearwater Revival';

--2.5 LIKE
SELECT * FROM INVOICE WHERE BILLINGADDRESS LIKE 'T%';

--2.6 BETWEEN
--SELECT * FROM INVOICE WHERE TOTAL > 15 AND TOTAL < 50;
SELECT * FROM INVOICE WHERE TOTAL BETWEEN 15 AND 50;

--2.7 DELETE


DELETE FROM INVOICELINE IL WHERE IL.INVOICEID IN (
    SELECT I.INVOICEID FROM INVOICE I WHERE I.CUSTOMERID = (
        SELECT C.CUSTOMERID FROM CUSTOMER C
        WHERE C.FIRSTNAME = 'Robert' 
        AND C.LASTNAME = 'Walter'
    )
);

DELETE FROM INVOICE WHERE INVOICE.CUSTOMERID IN (
    SELECT C.CUSTOMERID FROM CUSTOMER C
    WHERE C.FIRSTNAME = 'Robert' 
    AND C.LASTNAME = 'Walter'
);

DELETE FROM CUSTOMER WHERE FIRSTNAME = 'Robert' AND LASTNAME = 'Walter';

-- 3. SQL FUNCTIONS

-- 3.1
create or replace function current_date
return date is TODAYSDATE date;
BEGIN
    TODAYSDATE := CURRENT_TIMESTAMP;
    return TODAYSDATE;
END;
/

begin
    DBMS_OUTPUT.PUT_LINE(CURRENT_DATE);
end;
/

create or replace function LENGTH_MEDIA(MEDIA_ID IN VARCHAR2)
return number is LENGTH_MED number;
BEGIN
    SELECT LENGTH(MEDIATYPE.NAME) into length_med from MEDIATYPE
    WHERE MEDIATYPE.MEDIATYPEID = MEDIA_ID;
    return LENGTH_MED;
END;
/
begin
    DBMS_OUTPUT.PUT_LINE('STRING LENGTH ' || LENGTH_MEDIA(3));
end;
/

--3.2
CREATE OR REPLACE FUNCTION AVG_TOTAL 
RETURN NUMBER IS AVGTOTALBILL NUMBER;
BEGIN
    SELECT AVG(TOTAL) INTO AVGTOTALBILL FROM INVOICE;
    RETURN AVGTOTALBILL;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE(AVG_TOTAL);
END;
/

CREATE OR REPLACE FUNCTION MOSTEXPTRACK 
RETURN SYS_REFCURSOR IS S_TRACK SYS_REFCURSOR;
BEGIN
    OPEN S_TRACK FOR
        SELECT * FROM TRACK T1 WHERE UNITPRICE = (SELECT MAX(UNITPRICE) FROM TRACK);
    RETURN S_TRACK;
END;
/
DECLARE 
S SYS_REFCURSOR;
T TRACK%ROWTYPE;
BEGIN
S := MOSTEXPTRACK;
  DBMS_OUTPUT.PUT_LINE('THE MOST EXP TRACKS ARE');
  LOOP
    FETCH S INTO T;
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('THE TRACK NAME IS ' || T.NAME || ' COST ' || T.UNITPRICE);
  END LOOP;
  CLOSE S;
END;
/
-- 3.3
CREATE OR REPLACE FUNCTION AVG_PRICE_IL
RETURN NUMBER IS AVG_PRICE NUMBER;
BEGIN
    SELECT AVG(UNITPRICE) INTO AVG_PRICE FROM INVOICELINE;
    RETURN AVG_PRICE;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE(AVG_PRICE_IL);
END;
/
-- 3.4
CREATE OR REPLACE FUNCTION BORNAFTER1986
RETURN SYS_REFCURSOR 
IS MY_CURSOR SYS_REFCURSOR;
BEGIN
    OPEN MY_CURSOR FOR
        SELECT * FROM EMPLOYEE WHERE EMPLOYEE.BIRTHDATE > TO_DATE('1968','yyyy');
    RETURN MY_CURSOR;
END;
/

DECLARE 
S SYS_REFCURSOR;
E EMPLOYEE%ROWTYPE;
BEGIN
S := BORNAFTER1986;
  DBMS_OUTPUT.PUT_LINE('EMPLOYEES BORN AFTER 1986');
  LOOP
    FETCH S INTO E;
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(E.FIRSTNAME || ' ' ||
                        E.LASTNAME || ' IS BORN AFTER 1968');
  END LOOP;
  CLOSE S;
END;
/
DECLARE 
S CURSOR;
C_EMPLOYEEID EMPLOYEE.EMPLOYEEID%TYPE;
BEGIN
    BORNAFTER1986;
        LOOP
         FETCH S INTO C_EMPLOYEEID;
         EXIT WHEN S%NOTFOUND;
         DBMS_OUTPUT.PUT_LINE(C_EMPLOYEEID);
        END LOOP;
END;
--4
--4.1
CREATE OR REPLACE PROCEDURE GETFULLNAME (S OUT SYS_REFCURSOR)
IS
BEGIN
    OPEN S FOR
        SELECT FIRSTNAME, LASTNAME FROM EMPLOYEE;
END;
/
DECLARE 
S SYS_REFCURSOR;
FNAME EMPLOYEE.FIRSTNAME%TYPE;
LNAME EMPLOYEE.LASTNAME%TYPE;
BEGIN
GETFULLNAME(S);
  LOOP
    FETCH S INTO FNAME,LNAME;
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(FNAME ||' ' || LNAME ||' IS EMPLOYEES FULL NAME');
  END LOOP;
  CLOSE S;
END;
/
-- 4.2 Create a stored procedure that updates the personal information of an employee.
CREATE OR REPLACE PROCEDURE UPDATEPERSONALINFORMATION (
EMPID IN NUMBER DEFAULT NULL,
NEWFNAME IN VARCHAR2 DEFAULT NULL, 
NEWLNAME VARCHAR2 DEFAULT NULL,
NEWADDRESS VARCHAR2 DEFAULT NULL,
NEWCITY VARCHAR2 DEFAULT NULL,
NEWSTATE VARCHAR2 DEFAULT NULL,
NEWCOUNTRY VARCHAR2 DEFAULT NULL,
NEWPOSTALCODE VARCHAR2 DEFAULT NULL,
NEWPHONE VARCHAR2 DEFAULT NULL,
NEWFAX VARCHAR2 DEFAULT NULL,
NEWEMAIL VARCHAR2 DEFAULT NULL )
IS
BEGIN
    SAVEPOINT S;
    IF EMPID IS NOT NULL THEN
        UPDATE EMPLOYEE
            SET EMPLOYEE.FIRSTNAME = NEWFNAME WHERE NEWFNAME IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.LASTNAME = NEWLNAME WHERE NEWLNAME IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.ADDRESS = NEWADDRESS WHERE NEWADDRESS IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.CITY = NEWCITY WHERE NEWCITY IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.STATE = NEWSTATE WHERE NEWSTATE IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.COUNTRY = NEWCOUNTRY WHERE NEWCOUNTRY IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.POSTALCODE = NEWPOSTALCODE WHERE NEWPOSTALCODE IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.PHONE = NEWPHONE WHERE NEWPHONE IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.FAX = NEWFAX WHERE NEWFAX IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        UPDATE EMPLOYEE
            SET EMPLOYEE.EMAIL = NEWEMAIL WHERE NEWEMAIL IS NOT NULL AND EMPLOYEE.EMPLOYEEID = EMPID;
        COMMIT;
    ELSE
        DBMS_OUTPUT.PUT_LINE('NO EMPLOYEE ID');
    END IF;
    EXCEPTION
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('ERROR');
    ROLLBACK TO S;
END;
/

BEGIN
  UPDATEPERSONALINFORMATION(EMPID => 10, NEWFNAME => 'NOTMEMER');
END;
/
SELECT * FROM EMPLOYEE;

-- Create a stored procedure that returns the managers of an employee.
CREATE OR REPLACE PROCEDURE GETMANAGEREMPLOYEE (EMPID number, S OUT SYS_REFCURSOR)
IS
BEGIN
    OPEN S FOR
        SELECT E1.* FROM EMPLOYEE E1 WHERE E1.EMPLOYEEID = ( SELECT E2.REPORTSTO FROM EMPLOYEE E2 WHERE E2.EMPLOYEEID = EMPID);
END;
/
DECLARE 
S SYS_REFCURSOR;
EMP EMPLOYEE%ROWTYPE;
BEGIN
GETMANAGEREMPLOYEE(7,S);
  LOOP
    FETCH S INTO EMP;
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('MANAGER OF EMPLOYEE -> ' || EMP.FIRSTNAME ||' ' || EMP.LASTNAME||' IS A ' || EMP.TITLE);
  END LOOP;
  CLOSE S;
END;
/
--4.3 Create a stored procedure that returns the name and company of a customer.
CREATE OR REPLACE PROCEDURE GETCUSTOMERNAMECOMPANY (S OUT SYS_REFCURSOR)
IS
BEGIN
    OPEN S FOR
        SELECT FIRSTNAME, LASTNAME, COMPANY FROM CUSTOMER;
END;
/
DECLARE 
S SYS_REFCURSOR;
CUSTLASTNAME CUSTOMER.LASTNAME%TYPE;
CUSTFIRSTNAME CUSTOMER.FIRSTNAME%TYPE;
CUSTCOMPANY CUSTOMER.COMPANY%TYPE;
BEGIN
GETCUSTOMERNAMECOMPANY(S);
  LOOP
    FETCH S INTO CUSTLASTNAME, CUSTFIRSTNAME,CUSTCOMPANY;
    EXIT WHEN S%NOTFOUND;
    IF CUSTCOMPANY IS NULL THEN CUSTCOMPANY := 'NO COMPANY';
    END IF; 
    DBMS_OUTPUT.PUT_LINE(CUSTFIRSTNAME ||' ' || CUSTLASTNAME||' WORKS IN ' || CUSTCOMPANY);
  END LOOP;
  CLOSE S;
END;
/
--5.0 TRANSACTIONS
--Task ï¿½ Create a transaction that given a invoiceId will delete
--that invoice (There may be constraints that
--rely on this, find out how to resolve them).
CREATE OR REPLACE PROCEDURE GIVEIDDELETEINVOICE (INVID IN NUMBER)
IS
BEGIN
    DELETE 
        INVOICELINE WHERE INVOICELINE.INVOICEID = INVID;
    DELETE 
        INVOICE WHERE INVOICE.INVOICEID = INVID;
END;


/
SELECT * FROM INVOICE;  --320 22 06-NOV-12 120 S ORANGE
/
BEGIN
    GIVEIDDELETEINVOICE(320);
END;
/

--Create a transaction nested within a stored 
--procedure that inserts a new record in the Customer table
CREATE OR REPLACE PROCEDURE INSERTINTOCUSTOMER (
I_CUSTOMERID IN NUMBER,
I_FIRSTNAME IN VARCHAR2,
I_LASTNAME IN VARCHAR2,
I_COMPANY IN VARCHAR2,
I_ADDRESS IN VARCHAR,
I_CITY IN VARCHAR2,
I_STATE IN VARCHAR2,
I_COUNTRY IN VARCHAR2,
I_POSTALCODE IN VARCHAR2,
I_PHONE IN VARCHAR2,
I_FAX IN VARCHAR2,
I_EMAIL IN VARCHAR2,
I_SUPPORTREPID IN NUMBER
)
IS
BEGIN
    INSERT INTO CUSTOMER VALUES (I_CUSTOMERID, I_FIRSTNAME, I_LASTNAME,
                                I_COMPANY, I_ADDRESS, I_CITY, I_STATE,
                                I_COUNTRY, I_POSTALCODE, I_PHONE, I_FAX,
                                I_EMAIL, I_SUPPORTREPID);
END;
/

BEGIN
    INSERTINTOCUSTOMER(62, 'PEPE', 'DEDE', 'PEPECOM', '123 PEPE STREET', 
    'PEPE CITY', 'PE', 'USA', '123123', 
    '+1 (123) 456-789', 'NULL', 'PEPE@GMAIL.COM', 5);
END;
/

SELECT * FROM CUSTOMER;
/
--6.0 TRIGGERS
--6.1 AFTER/FOR
--Create an after insert trigger on the employee table 
--fired after a new record is inserted into the table.

CREATE OR REPLACE TRIGGER TR_INSERT_EMPLOYEE
AFTER INSERT ON EMPLOYEE
BEGIN
    DBMS_OUTPUT.PUT_LINE('FIRE AFTER INSERTING INTO EMPLOYEE');
END;
/
--Create an after update 
--trigger on the album table that fires after a row is inserted in the table
CREATE OR REPLACE TRIGGER TR_UPDATE_ALBUM
AFTER UPDATE ON ALBUM
BEGIN
    DBMS_OUTPUT.PUT_LINE('FIRES AFTER UPDATING IN ALBUM');
END;
/
--Create an after delete trigger on the 
--customer table that fires after a row is deleted from the table.
CREATE OR REPLACE TRIGGER TR_DELETE_CUSTOMER
AFTER DELETE ON CUSTOMER
BEGIN
    DBMS_OUTPUT.PUT_LINE('FIRES AFTER DELETE FROM CUSTOMER');
END;
/



--7.0 JOINS 
--7.1 Create an inner join that joins customers and orders 
--and specifies the name of the customer and the invoiceId.
SELECT FIRSTNAME, LASTNAME,INVOICEID FROM CUSTOMER
INNER JOIN INVOICE ON INVOICE.CUSTOMERID = CUSTOMER.CUSTOMERID;

--7.2 
--Task ï¿½ Create an outer join that joins the customer and invoice table, 
--specifying the CustomerId,firstname, lastname, invoiceId, and total.
SELECT CUS.CUSTOMERID, CUS.FIRSTNAME, CUS.LASTNAME, INV.INVOICEID, 
INV.TOTAL FROM CUSTOMER CUS FULL OUTER JOIN 
INVOICE INV ON CUS.CUSTOMERID = INV.CUSTOMERID;

--7.3
--Create a right join that joins album and artist specifying artist name and title.
SELECT ART.NAME, ALB.TITLE FROM ARTIST ART
RIGHT JOIN ALBUM ALB ON ART.ARTISTID = ALB.ARTISTID;

--7.4
--Create a cross join that joins album 
--and artist and sorts by artist name in ascending order.
SELECT * FROM ARTIST CROSS JOIN ALBUM ORDER BY ARTIST.NAME ASC;

--7.5
--Perform a self-join on the employee table, 
--joining on the reportsto column.
SELECT E1.FIRSTNAME|| ' ' || E1.LASTNAME || ' reports to ' || E2.FIRSTNAME || ' '
|| E2.LASTNAME
FROM EMPLOYEE E1, EMPLOYEE E2
WHERE E1.REPORTSTO = E2.EMPLOYEEID;

--9.0
--Create a .bak file for the Chinook database.

