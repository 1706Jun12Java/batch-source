--BEARS!!!

--CREATE TABLES 
CREATE TABLE BEAR (
  BEAR_ID INTEGER PRIMARY KEY,
  BEAR_TYPE_ID INTEGER,
  BEAR_NAME VARCHAR2(100),
  BEAR_BIRTHDATE DATE,
  BEAR_WEIGHT INTEGER DEFAULT 200,
  CAVE_ID INTEGER
);

CREATE TABLE BEAR_TYPE (
  BEAR_TYPE_ID INTEGER PRIMARY KEY,
  BEAR_TYPE_NAME VARCHAR2(100)
);

CREATE TABLE CAVE (
  CAVE_ID INTEGER PRIMARY KEY,
  CAVE_NAME VARCHAR2(100),
  MAX_BEARS INTEGER DEFAULT 4
);

CREATE TABLE BEEHIVE (
  BEEHIVE_ID INTEGER PRIMARY KEY,
  BEEHIVE_WEIGHT INTEGER DEFAULT 50
);

CREATE TABLE BEAR_BEEHIVE (
  BEAR_ID INTEGER,
  BEEHIVE_ID INTEGER,
  PRIMARY KEY (BEAR_ID, BEEHIVE_ID)
);

--ADD FOREIGN KEY CONSTRAINTS
ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_BEAR_TYPE
FOREIGN KEY (BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID);

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_CAVE
FOREIGN KEY (CAVE_ID) REFERENCES CAVE(CAVE_ID);

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEAR
FOREIGN KEY (BEAR_ID) REFERENCES BEAR(BEAR_ID);

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEEHIVE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID);

--ADD A CHECK CONSTRAINT TO KEEP WEIGHTS >0
ALTER TABLE BEAR
ADD CONSTRAINT CK_BEAR_WEIGHT_POSITIVE CHECK (BEAR_WEIGHT > 0);

ALTER TABLE BEEHIVE
ADD CONSTRAINT CK_HIVE_WEIGHT_POSITIVE CHECK (BEEHIVE_WEIGHT > 0);

--ADD UNIQUE CONSTRAINT ON CAVE NAME, BEAR TYPE NAME
ALTER TABLE CAVE
ADD CONSTRAINT UQ_CAVE_NAME UNIQUE (CAVE_NAME);

ALTER TABLE BEAR_TYPE
ADD CONSTRAINT UQ_TYPE_NAME UNIQUE (BEAR_TYPE_NAME);

--SOME DATA
INSERT INTO BEAR_TYPE VALUES (1,'GRIZZLY');
INSERT INTO BEAR_TYPE VALUES (2,'POLAR');
INSERT INTO BEAR_TYPE VALUES (3,'PANDA');

INSERT INTO BEAR VALUES(1,2,'PADDINGTON','27-NOV-1997',DEFAULT,NULL);

TRUNCATE TABLE BEAR_TYPE;

--NOTE: WE DROPPED AND RE-ADDED THIS! 
ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_BEAR_TYPE
FOREIGN KEY (BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID) 
ON DELETE SET NULL;

DELETE FROM BEAR_TYPE WHERE BEAR_TYPE_ID = 2;

INSERT INTO BEAR VALUES(2,3,'PANDA1','27-NOV-1997',DEFAULT,NULL);

TRUNCATE TABLE BEAR_TYPE;

DELETE FROM BEAR_TYPE;

TRUNCATE TABLE BEAR; --YELLS AT YOU BECAUSE BEAR_BEEHIVE REFERENCES IT

DELETE FROM BEAR;

--SEQUENCES
CREATE SEQUENCE SQ_BEAR_PK
START WITH 1
INCREMENT BY 2;

CREATE SEQUENCE SQ_BEAR_TYPE_PK
START WITH 1
INCREMENT BY 2;

CREATE SEQUENCE SQ_CAVE_PK
START WITH 1
INCREMENT BY 2;

CREATE SEQUENCE SQ_BEEHIVE_PK
START WITH 1
INCREMENT BY 2;

--CREATE BEFORE INSERT TRIGGERS
CREATE OR REPLACE TRIGGER TR_INSERT_BEAR
BEFORE INSERT ON BEAR
FOR EACH ROW
BEGIN
  SELECT SQ_BEAR_PK.NEXTVAL INTO :NEW.BEAR_ID FROM DUAL;
  --DUAL IS A DUMMY TABLE. USE IT WHEN YOU DON'T REQUIRE A TABLE
  --BUT NEED TABLE-LIKE SYNTAX
END;

SELECT * FROM DUAL;

CREATE OR REPLACE TRIGGER TR_INSERT_BEAR_TYPE
BEFORE INSERT ON BEAR_TYPE
FOR EACH ROW
BEGIN
  SELECT SQ_BEAR_TYPE_PK.NEXTVAL INTO :NEW.BEAR_TYPE_ID FROM DUAL;
  --DUAL IS A DUMMY TABLE. USE IT WHEN YOU DON'T REQUIRE A TABLE
  --BUT NEED TABLE-LIKE SYNTAX
END;

CREATE OR REPLACE TRIGGER TR_INSERT_CAVE
BEFORE INSERT ON CAVE
FOR EACH ROW
BEGIN
  SELECT SQ_CAVE_PK.NEXTVAL INTO :NEW.CAVE_ID FROM DUAL;
  --DUAL IS A DUMMY TABLE. USE IT WHEN YOU DON'T REQUIRE A TABLE
  --BUT NEED TABLE-LIKE SYNTAX
END;

CREATE OR REPLACE TRIGGER TR_INSERT_BEEHIVE
BEFORE INSERT ON BEEHIVE
FOR EACH ROW
BEGIN
  SELECT SQ_BEEHIVE_PK.NEXTVAL INTO :NEW.BEEHIVE_ID FROM DUAL;
  --DUAL IS A DUMMY TABLE. USE IT WHEN YOU DON'T REQUIRE A TABLE
  --BUT NEED TABLE-LIKE SYNTAX
END;

INSERT INTO BEAR_TYPE (BEAR_TYPE_NAME) VALUES ('GRIZZLY');
INSERT INTO BEAR_TYPE (BEAR_TYPE_NAME) VALUES ('POLAR');
INSERT INTO BEAR_TYPE (BEAR_TYPE_NAME) VALUES ('PANDA');

INSERT INTO CAVE (CAVE_NAME,MAX_BEARS) VALUES ('AWESOMECAVE1',DEFAULT);
INSERT INTO CAVE (CAVE_NAME,MAX_BEARS) VALUES ('AWESOMECAVE2',10);

INSERT INTO BEEHIVE (BEEHIVE_WEIGHT) VALUES (DEFAULT);
INSERT INTO BEEHIVE (BEEHIVE_WEIGHT) VALUES (75);
INSERT INTO BEEHIVE (BEEHIVE_WEIGHT) VALUES (10);

INSERT INTO BEAR (BEAR_TYPE_ID,BEAR_NAME,BEAR_BIRTHDATE,BEAR_WEIGHT,CAVE_ID)
VALUES(3,'PO','27-NOV-1997',DEFAULT,1);

INSERT INTO BEAR (BEAR_TYPE_ID,BEAR_NAME,BEAR_BIRTHDATE,BEAR_WEIGHT,CAVE_ID)
VALUES(1,'Yogi','25-NOV-1997',500,1);
INSERT INTO BEAR (BEAR_TYPE_ID,BEAR_NAME,BEAR_BIRTHDATE,BEAR_WEIGHT,CAVE_ID)
VALUES(5,'Snowflake','27-NOV-1972',1000,1);

--CREATE VIEW TO SHOW HOW MANY BEARS PER CAVE
CREATE VIEW VW_BEARS_PER_CAVE (CAVE,NUMBEAR)
AS 
  SELECT CAVE_NAME,COUNT(BEAR_ID)
  FROM BEAR,CAVE
  WHERE BEAR.CAVE_ID=CAVE.CAVE_ID
  GROUP BY CAVE_NAME;
  
SELECT * FROM VW_BEARS_PER_CAVE;

--FUN WITH FUNCTIONS
CREATE OR REPLACE FUNCTION FIND_MAX_NUMBER (X IN NUMBER, Y IN NUMBER)
RETURN NUMBER
IS
Z NUMBER;
BEGIN
  IF X>Y THEN 
    Z:=X;
  ELSE
    Z:=Y;
  END IF;
  RETURN Z;
END;

--BEGIN AND END ARE NOT TIED TO TRANSACTIONS!!! 

DECLARE 
--SOME VARIABLES
FIRST_NUM NUMBER;
SECOND_NUM NUMBER;
MAX_NUM NUMBER;
BEGIN
--DOING SOME THINGS WITH THOSE VARIABLES
FIRST_NUM := 22;
SECOND_NUM := 42;
MAX_NUM := FIND_MAX_NUMBER(FIRST_NUM,SECOND_NUM);
DBMS_OUTPUT.PUT_LINE('MAX: '||MAX_NUM);
END;

CREATE OR REPLACE FUNCTION FIND_MAX_CHAR (X IN VARCHAR2, Y IN VARCHAR2)
RETURN VARCHAR2
IS
Z VARCHAR2(4);
BEGIN
  IF X>Y THEN 
    Z:=X;
  ELSE
    Z:=Y;
  END IF;
  RETURN Z;
END;

--BEGIN AND END ARE NOT TIED TO TRANSACTIONS!!! 

DECLARE 
--SOME VARIABLES
FIRST_CHAR VARCHAR2(4);
SECOND_CHAR VARCHAR2(4);
MAX_CHAR VARCHAR2(4);
BEGIN
--DOING SOME THINGS WITH THOSE VARIABLES
FIRST_CHAR := 'a';
SECOND_CHAR := 'z';
MAX_CHAR := FIND_MAX_CHAR(FIRST_CHAR,SECOND_CHAR);
DBMS_OUTPUT.PUT_LINE('MAX: '||MAX_CHAR);
END;

--STORED PROCEDURES
CREATE OR REPLACE PROCEDURE HELLO_WORLD_PROCEDURE
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('HELLO WORLD');
END;
--INVOKE HELLO_WORLD
BEGIN 
HELLO_WORLD_PROCEDURE();
END;

--PROCEDURE WITH CURSORS
CREATE OR REPLACE PROCEDURE GET_ALL_BEARS (S OUT SYS_REFCURSOR)
IS
BEGIN
  OPEN S FOR 
  SELECT BEAR_ID, BEAR_NAME FROM BEAR;
END;

DECLARE 
S SYS_REFCURSOR;
SOME_ID BEAR.BEAR_ID%TYPE;
SOME_NAME BEAR.BEAR_NAME%TYPE;
BEGIN
GET_ALL_BEARS(S);
  LOOP
    FETCH S INTO SOME_ID,SOME_NAME;
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(SOME_ID||' IS CURRENT ID, '||SOME_NAME||' IS CURRENT NAME');
  END LOOP;
  CLOSE S;
END;

--FEED THE BEAR
CREATE OR REPLACE PROCEDURE SP_FEED_BEAR(
  B_ID IN NUMBER, H_ID IN NUMBER, HONEY_AMT IN NUMBER)
IS
BB_EXISTS INTEGER;
BEGIN
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  --DECREASE BEEHIVE WEIGHT
  SELECT COUNT(BB.BEAR_ID) INTO BB_EXISTS FROM BEAR_BEEHIVE BB
  WHERE BB.BEAR_ID = B_ID
    AND BB.BEEHIVE_ID = H_ID;
  DBMS_OUTPUT.PUT_LINE(BB_EXISTS);
  IF BB_EXISTS > 0 THEN
  UPDATE BEEHIVE 
  SET BEEHIVE_WEIGHT = BEEHIVE_WEIGHT-HONEY_AMT
  WHERE BEEHIVE_ID = H_ID;
  --INCREASE BEAR WEIGHT
  UPDATE BEAR 
  SET BEAR_WEIGHT = BEAR_WEIGHT + HONEY_AMT 
  WHERE BEAR_ID  = B_ID;
  DBMS_OUTPUT.PUT_LINE('FED BEAR '||HONEY_AMT||' POUNDS OF HONEY');
  ELSE 
  DBMS_OUTPUT.PUT_LINE('FAILED TO FEED BEAR');
  END IF;
  COMMIT;
  EXCEPTION
  WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('FAILED TO FEED BEAR');
  --https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/07_errs.htm 
  ROLLBACK;
END;

BEGIN
  SP_FEED_BEAR(1,1,20);
END;

INSERT INTO BEAR_BEEHIVE VALUES(1,1); --MAKE SURE YOU COMMITTED!!!

SELECT COUNT(*) FROM BEAR_BEEHIVE BB
  WHERE BB.BEAR_ID = 1
    AND BB.BEEHIVE_ID = 1;
